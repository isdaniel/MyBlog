---
title: Asp.net架構 & Asp.net MVC 原始碼－ HttpApplication (第四天)
date: 
tags: [C#,Asp.net,Asp.net-MVC,SourceCode]
categories: [C#]
---

## 前言：

附上`Asp.net`執行請求流程圖.

![瀏覽器請求IIS流程](https://raw.githubusercontent.com/isdaniel/MyBlog/master/source/images/IIS_Asp.net_Process.png)

上一篇文章我們知道`HttpApplicationFactory`會返回一個`HttpApplication`給`HttpRuntime`來呼叫使用.

`HttpApplication`可謂是我們Asp.net中很複雜但很重要的類別，`Global.cs`中是繼承這個類別

但為什麼需要繼承這個類別呢? 讓我們繼續看下去.

> 查看原始碼好站 [Reference Source](https://referencesource.microsoft.com/)

> 此文的程式碼比較多我會在原始碼上邊上說明相對應編號方便大家觀看

## HttpApplication

### InitInternal

在介紹`HttpApplicationFactory`文章中,談到`HttpApplication`透過`InitInternal`方法來進行初始化.

1. 初始化`HttpModule`，讀取`Host config`或`appconfig` 註冊的HttpMoudle,並調用Init方法，使用`AOP`編成方式註冊使用事件
2. 提供一個Hock給繼承Application物件來初始化設定使用
3. 判斷要走管道模式還是經典模式
4. 建置Pipleline流程

所以我們看到讀取`HttpModule`在`InitInternal`初始化方法執行.

```CSharp
internal void InitInternal(HttpContext context, HttpApplicationState state, MethodInfo[] handlers){
	// Remember state
	_state = state;

	PerfCounters.IncrementCounter(AppPerfCounter.PIPELINES);

	try {
		try {
			// Remember context for config lookups
			_initContext = context;
			_initContext.ApplicationInstance = this;

			// Set config path to be application path for the application initialization
			context.ConfigurationPath = context.Request.ApplicationPathObject;

			// keep HttpContext.Current working while running user code
			using (new DisposableHttpContextWrapper(context)) {

				// 1.初始化HttpModule.
				if (HttpRuntime.UseIntegratedPipeline) {

					try {
						context.HideRequestResponse = true;
						_hideRequestResponse = true;
						InitIntegratedModules();
					}
					finally {
						context.HideRequestResponse = false;
						_hideRequestResponse = false;
					}
				}
				else {
					InitModules();
				}

				// Hookup event handlers via reflection
				if (handlers != null)
					HookupEventHandlersForApplicationAndModules(handlers);

				// Initialization of the derived class
				_context = context;
				if (HttpRuntime.UseIntegratedPipeline && _context != null) {
					_context.HideRequestResponse = true;
				}
				_hideRequestResponse = true;

				try {
					//2.提供一個Hock給繼承Application物件來初始化設定使用
					Init();
				}
				catch (Exception e) {
					RecordError(e);
				}
			}

			if (HttpRuntime.UseIntegratedPipeline && _context != null) {
				_context.HideRequestResponse = false;
			}
			_hideRequestResponse = false;
			_context = null;
			_resumeStepsWaitCallback= new WaitCallback(this.ResumeStepsWaitCallback);

			//3. 判斷要走管道模式還是經典模式
			if (HttpRuntime.UseIntegratedPipeline) {
				_stepManager = new PipelineStepManager(this);
			}
			else {
				_stepManager = new ApplicationStepManager(this);
			}

            //4. 建置Pipleline流程
			_stepManager.BuildSteps(_resumeStepsWaitCallback);
		}
		finally {
			_initInternalCompleted = true;

			// Reset config path
			context.ConfigurationPath = null;
			// don't hold on to the context
			_initContext.ApplicationInstance = null;
			_initContext = null;
		}
	}
	catch { // Protect against exception filters
		throw;
	}
}
```

#### 管道模式 vs 經典模式

下面兩張圖是**管道模式**和**經典模式**

**經典模式**

![經典模式](https://mytechnetknowhows.files.wordpress.com/2015/05/aspnet-integration-with-iis6-0.jpg)

**管道模式**

![管道模式](https://mytechnetknowhows.files.wordpress.com/2015/05/aspnet-integration-with-iis-7-integrated-mode.jpg)

[圖片來源](https://mytechnetknowhows.wordpress.com/2015/05/24/asp-net-and-iis-integration-iis-6-0-and-ii6-0-iis-7-0-iis-7-5-iis-8-0/)

除了執行流程不一樣跟一些差異外，他們最終還是為了要找到一個`HttpHandler`來執行.

## stepManager.BuildSteps 建置Pipleline流程
