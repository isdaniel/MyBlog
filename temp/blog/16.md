---
title: 從Asp.net框架角度進入Asp.net MVC原始碼－InvokeAction(一) (第16天)
date: 
tags: [C#,Asp.net,Asp.net-MVC,SourceCode]
categories: [C#]
---
# Agenda<!-- omit in toc -->
- [前言](#%e5%89%8d%e8%a8%80)
- [InvokeAction](#invokeaction)
  - [取得ControllerDescriptor(ReflectedControllerDescriptor)](#%e5%8f%96%e5%be%97controllerdescriptorreflectedcontrollerdescriptor)
- [ActionDescriptor(ReflectedActionDescriptor)](#actiondescriptorreflectedactiondescriptor)
  - [ReflectedActionDescriptor 取得ActionMethod參數資訊](#reflectedactiondescriptor-%e5%8f%96%e5%be%97actionmethod%e5%8f%83%e6%95%b8%e8%b3%87%e8%a8%8a)
- [取得Action執行參數](#%e5%8f%96%e5%be%97action%e5%9f%b7%e8%a1%8c%e5%8f%83%e6%95%b8)

## 前言


## InvokeAction

在`ControllerActionInvoker`最重要的就是`InvokeAction`方法,因為主要透過他去呼叫`ActionResult`抽象類別`ExecuteResult`方法.

`InvokeAction`有兩個參數

* `ControllerContext`:對於`RequestContext`,`RouteData`,使用`Controller`資訊封裝.
* `actionName`:此次呼叫方法(從`RouteData`取得`action`值)

```csharp
public virtual bool InvokeAction(ControllerContext controllerContext, string actionName)
```

除了呼叫`ExecuteResult`方法外還做了其他事情.

對於藉由`ControllerContext`封裝兩個物件.

* `ControllerDescriptor`
* `ActionDescriptor`

這兩個物件在此方法中很重要.

```csharp
ControllerDescriptor controllerDescriptor = GetControllerDescriptor(controllerContext);
ActionDescriptor actionDescriptor = FindAction(controllerContext, controllerDescriptor, actionName);
```

### 取得ControllerDescriptor(ReflectedControllerDescriptor)

`GetControllerDescriptor`會返回一個`ReflectedControllerDescriptor`物件.

```csharp
protected virtual ControllerDescriptor GetControllerDescriptor(ControllerContext controllerContext)
{
	Type controllerType = controllerContext.Controller.GetType();
	ControllerDescriptor controllerDescriptor = DescriptorCache.GetDescriptor(
		controllerType: controllerType,
		creator: (Type innerType) => new ReflectedControllerDescriptor(innerType),
		state: controllerType);
	return controllerDescriptor;
}
```

`ReflectedControllerDescriptor`裡面有許多重要資訊,我會列出其重要成員和代表含意.

1. `ControllerType`此次執行`Controller`類型
2. **(重要)**`FindAction`透過此方法取得`ActionDescriptor`物件.
3. `GetFilterAttributes`取的此`Controller`上的`AcitonFilter`

```csharp
public abstract class ControllerDescriptor : ICustomAttributeProvider, IUniquelyIdentifiable
{
	public virtual string ControllerName
	{
		get
		{
			string typeName = ControllerType.Name;
			if (typeName.EndsWith("Controller", StringComparison.OrdinalIgnoreCase))
			{
				return typeName.Substring(0, typeName.Length - "Controller".Length);
			}

			return typeName;
		}
	}

	public abstract Type ControllerType { get; }

	public abstract ActionDescriptor FindAction(ControllerContext controllerContext, string actionName);

	public abstract ActionDescriptor[] GetCanonicalActions();

	public virtual IEnumerable<FilterAttribute> GetFilterAttributes(bool useCache)
	{
		return GetCustomAttributes(typeof(FilterAttribute), inherit: true).Cast<FilterAttribute>();
	}

	public virtual bool IsDefined(Type attributeType, bool inherit)
	{
		if (attributeType == null)
		{
			throw new ArgumentNullException("attributeType");
		}

		return false;
	}
}
```

`ReflectedControllerDescriptor`實現`FindAction`抽象方法.

主要透過反射取得此`Controller`物件中相對應Action名稱的方法,並把他封裝到`ReflectedActionDescriptor`類別中返回.

```csharp
public override ActionDescriptor FindAction(ControllerContext controllerContext, string actionName)
{
	if (controllerContext == null)
	{
		throw new ArgumentNullException("controllerContext");
	}
	if (String.IsNullOrEmpty(actionName))
	{
		throw new ArgumentException(MvcResources.Common_NullOrEmpty, "actionName");
	}

	MethodInfo matched = _selector.FindActionMethod(controllerContext, actionName);
	if (matched == null)
	{
		return null;
	}

	return new ReflectedActionDescriptor(matched, actionName, this);
}
``` 

## ActionDescriptor(ReflectedActionDescriptor)

`ActionDescriptor`是另一個在`InovkeAction`很重要物件

### ReflectedActionDescriptor 取得ActionMethod參數資訊

上面提到`ActionDescriptor`預設使用`ReflectedActionDescriptor`

```csharp
public override ParameterDescriptor[] GetParameters()
{
	return ActionDescriptorHelper.GetParameters(this, MethodInfo, ref _parametersCache);
}

private static ParameterDescriptor[] LazilyFetchParametersCollection(ActionDescriptor actionDescriptor, MethodInfo methodInfo, ref ParameterDescriptor[] parametersCache)
{
	// Frequently called, so ensure the delegates remain static
	return DescriptorUtil.LazilyFetchOrCreateDescriptors(
		cacheLocation: ref parametersCache,
		initializer: (CreateDescriptorState state) => state.MethodInfo.GetParameters(),
		converter: (ParameterInfo parameterInfo, CreateDescriptorState state) => new ReflectedParameterDescriptor(parameterInfo, state.ActionDescriptor),
		state: new CreateDescriptorState() { ActionDescriptor = actionDescriptor, MethodInfo = methodInfo });
}
```

## 取得Action執行參數

透過`GetParameterValues`方法取得一個字典`IDictionary<string, object>`,這個字典是`Action`方法呼叫參數大功臣.

* `key`：參數名稱
* `value`：參數值

> 在`ActionFitlerAttribute.OnActionExcuting`重載方法,參數`ActionExecutingContext`物件中有一個屬性`public virtual IDictionary<string, object> ActionParameters { get; set; }`
> 他透過`IValueProvider`解析完傳入字串轉換成一個存放參數字典.

讓我們了解一下這部分是如何完成.

```csharp
protected virtual IDictionary<string, object> GetParameterValues(ControllerContext controllerContext, ActionDescriptor actionDescriptor)
{
	Dictionary<string, object> parametersDict = new Dictionary<string, object>(StringComparer.OrdinalIgnoreCase);
	ParameterDescriptor[] parameterDescriptors = actionDescriptor.GetParameters();

	foreach (ParameterDescriptor parameterDescriptor in parameterDescriptors)
	{
		parametersDict[parameterDescriptor.ParameterName] = GetParameterValue(controllerContext, parameterDescriptor);
	}
	return parametersDict;
}
```

在呼叫`GetParameters`方法會呼叫`ActionDescriptorHelper.GetParameters`,利用反射取得`MethodInfo.GetParameters`在將裡面資訊封裝到`ReflectedParameterDescriptor`物件中.

`ReflectedParameterDescriptor`包含幾個重要屬性

1. `ParameterType`:參數類型
2. `ParameterName`:參數名稱
3. `DefaultValue`:參數預設值

上面幾個為`Action`參數元數據資料.

利用`ReflectedParameterDescriptor`之前封裝方法參數資訊對於`GetParameterValue`方法執行物件建立.

`GetParameterValue`方法中有幾個重要的`Field`

* `IModelBinder`使用`DefaultModelBinder`來綁定使用參數
* `IValueProvider`依靠`ValueProviderFactories`來取使用哪個Provider得並綁訂傳入參數資料.

```csharp
protected virtual object GetParameterValue(ControllerContext controllerContext, ParameterDescriptor parameterDescriptor)
{
	Type parameterType = parameterDescriptor.ParameterType;
	IModelBinder binder = GetModelBinder(parameterDescriptor);
	IValueProvider valueProvider = controllerContext.Controller.ValueProvider;
	string parameterName = parameterDescriptor.BindingInfo.Prefix ?? parameterDescriptor.ParameterName;
	Predicate<string> propertyFilter = GetPropertyFilter(parameterDescriptor);

	ModelBindingContext bindingContext = new ModelBindingContext()
	{
		FallbackToEmptyPrefix = (parameterDescriptor.BindingInfo.Prefix == null), // only fall back if prefix not specified
		ModelMetadata = ModelMetadataProviders.Current.GetMetadataForType(null, parameterType),
		ModelName = parameterName,
		ModelState = controllerContext.Controller.ViewData.ModelState,
		PropertyFilter = propertyFilter,
		ValueProvider = valueProvider
	};

	object result = binder.BindModel(controllerContext, bindingContext);
	return result ?? parameterDescriptor.DefaultValue;
}
```