---
title: Asp.net架構 & Asp.net MVC 原始碼－Action(二) (第16天)
date: 
tags: [C#,Asp.net,Asp.net-MVC,SourceCode]
categories: [C#]
---

# Agenda<!-- omit in toc -->
- [前言](#%E5%89%8D%E8%A8%80)
- [IAuthenticationFilter and AuthenticationContext](#IAuthenticationFilter-and-AuthenticationContext)
  - [InvokeAuthenticationFilters方法](#InvokeAuthenticationFilters%E6%96%B9%E6%B3%95)
- [IAuthorizationFilter and AuthorizationContext](#IAuthorizationFilter-and-AuthorizationContext)
  - [AuthorizationContext類別](#AuthorizationContext%E9%A1%9E%E5%88%A5)

## 前言

上篇和大家介紹`Filter`去是如何取得且我們可以透過IOC容器註冊`IFilterProvider`來擴充取得`Filter`注入點.

在**ASP.NET MVC**的`Filter`，在執行目標前後彈性擴充額外操作(繼承`ActionFilter`並掛`Attribute`)，這是一種典型的`AOP`設計模式

本篇會和大家繼續分享`InvokeAction`後續動作.

## IAuthenticationFilter and AuthenticationContext  

取得完所有的`Filter`物件後,會呼叫一個`InvokeAuthenticationFilters`方法,主要是用此方法執行所有註冊的`IAuthenticationFilter`.

```csharp
try
{
    AuthenticationContext authenticationContext = InvokeAuthenticationFilters(controllerContext, filterInfo.AuthenticationFilters, actionDescriptor);

    if (authenticationContext.Result != null)
    {
        AuthenticationChallengeContext challengeContext = InvokeAuthenticationFiltersChallenge(
            controllerContext, filterInfo.AuthenticationFilters, actionDescriptor,
            authenticationContext.Result);
        InvokeActionResult(controllerContext, challengeContext.Result ?? authenticationContext.Result);
    }
    else
    {
        //.....
    }
}
```

### InvokeAuthenticationFilters方法

```csharp
protected virtual AuthenticationContext InvokeAuthenticationFilters(
	ControllerContext controllerContext,
	IList<IAuthenticationFilter> filters, 
	ActionDescriptor actionDescriptor)
{

	//....
	AuthenticationContext context = new AuthenticationContext(controllerContext, actionDescriptor,
		originalPrincipal);
	foreach (IAuthenticationFilter filter in filters)
	{
		filter.OnAuthentication(context);
		// short-circuit evaluation when an error occurs
		if (context.Result != null)
		{
			break;
		}
	}

	IPrincipal newPrincipal = context.Principal;

	if (newPrincipal != originalPrincipal)
	{
		Contract.Assert(context.HttpContext != null);
		context.HttpContext.User = newPrincipal;
		Thread.CurrentPrincipal = newPrincipal;
	}

	return context;
}
```

`AuthenticationContext`中重要的一個屬性是

* `public ActionResult Result { get; set; }` 只要這個物件不為`null`就會直接返回此次請求.

```csharp
public class AuthenticationContext : ControllerContext
{

	public AuthenticationContext(ControllerContext controllerContext, ActionDescriptor actionDescriptor,
		IPrincipal principal)
		: base(controllerContext)
	{
		if (actionDescriptor == null)
		{
			throw new ArgumentNullException("actionDescriptor");
		}

		ActionDescriptor = actionDescriptor;
		Principal = principal;
	}
	
	/// <summary>Gets or sets the action descriptor.</summary>
	public ActionDescriptor ActionDescriptor { get; set; }

	/// <summary>Gets or sets the currently authenticated principal.</summary>
	public IPrincipal Principal { get; set; }

	/// <summary>
	/// Gets or sets the error result, which indicates that authentication was attempted and failed.
	/// </summary>
	public ActionResult Result { get; set; }
}
```

在方法中我封裝一個`AuthenticationContext`物件,把它當作參數傳入`IAuthenticationFilter.OnAuthentication`方法中(這就是我們在繼承`AuthenticationFilter`使用`AuthenticationContext`物件)

值得一提程式會判斷`context.Result`是否為`null`來當作迴圈中斷點.

```csharp
if (context.Result != null)
{
    break;
}
```

這個邏輯是我們對於`Authentication`驗證失敗後想要直接返回請求可以透過把`context.Result`給一個值(`ActionResult`物件),外面會照`authenticationContext.Result`是否為`null`為依據判斷是否繼續執行後面動作.

## IAuthorizationFilter and AuthorizationContext

在下一個步驟是檢驗`IAuthorizationFilter`過濾器,執行過程和`IAuthenticationFilter`過濾器基本上一樣

依照物件內`Result`屬性是否為`null`來當作後續執行依據.

```csharp
AuthorizationContext authorizationContext = InvokeAuthorizationFilters(controllerContext, filterInfo.AuthorizationFilters, actionDescriptor);
if (authorizationContext.Result != null)
{
	AuthenticationChallengeContext challengeContext = InvokeAuthenticationFiltersChallenge(
		controllerContext, filterInfo.AuthenticationFilters, actionDescriptor,
		authorizationContext.Result);
	InvokeActionResult(controllerContext, challengeContext.Result ?? authorizationContext.Result);
}

public interface IAuthorizationFilter
{
    void OnAuthorization(AuthorizationContext filterContext);
}
```

### AuthorizationContext類別

```csharp
public class AuthorizationContext : ControllerContext
{
	//.....

	public virtual ActionDescriptor ActionDescriptor { get; set; }

	public ActionResult Result { get; set; }
}
```

既然`IAuthenticationFilter`和`IAuthorizationFilter`過濾器驗證東西都很類似為什麼要分成兩個呢?

如果仔細比較會發現`IAuthenticationFilter`除了上面動作還多了其他含意(設置`Principal`).

